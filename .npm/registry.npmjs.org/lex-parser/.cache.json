{"_id":"lex-parser","_rev":"19-41f01dabf0132dfe6964219f8b3d67bf","name":"lex-parser","description":"A parser for lexical grammars used by jison","dist-tags":{"latest":"0.1.4"},"versions":{"0.0.1":{"name":"lex-parser","version":"0.0.1","description":"A parser for lexical grammars used by jison","main":"lex-parser.js","scripts":{"test":"make test"},"repository":"","keywords":["lexical","grammar","parser","jison"],"author":{"name":"Zach Carter"},"license":"MIT","devDependencies":{"jison":"0.3.12","test":"*"},"readme":"# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require('lex-parser');\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME              [a-zA-Z_][a-zA-Z0-9_-]*\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>[^{}]+          return 'ACTION_BODY'\n    <action>\"{\"             yy.depth++; return '{'\n    <action>\"}\"             yy.depth == 0 ? this.begin('trail') : yy.depth--; return '}'\n\n    <conditions>{NAME}      return 'NAME'\n    <conditions>\">\"         this.popState(); return '>'\n    <conditions>\",\"         return ','\n    <conditions>\"*\"         return '*'\n\n    <rules>\\n+              /* */\n    <rules>\\s+              this.begin('indented')\n    <rules>\"%%\"             this.begin('code'); return '%%'\n    <rules>[a-zA-Z0-9_]+    return 'CHARACTER_LIT'\n\n    <options>{NAME}         yy.options[yytext] = true\n    <options>\\n+            this.begin('INITIAL')\n    <options>\\s+\\n+         this.begin('INITIAL')\n    <options>\\s+            /* empty */\n\n    <start_condition>{NAME}         return 'START_COND'\n    <start_condition>\\n+            this.begin('INITIAL')\n    <start_condition>\\s+\\n+         this.begin('INITIAL')\n    <start_condition>\\s+            /* empty */\n\n    <trail>.*\\n+                    this.begin('rules')\n\n    <indented>\"{\"                   yy.depth = 0; this.begin('action'); return '{'\n    <indented>\"%{\"(.|\\n)*?\"%}\"      this.begin('trail'); yytext = yytext.substr(2, yytext.length-4);return 'ACTION'\n    \"%{\"(.|\\n)*?\"%}\"                yytext = yytext.substr(2, yytext.length-4); return 'ACTION'\n    <indented>.+                    this.begin('rules'); return 'ACTION'\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"             /* ignore */\n    \"//\".*                          /* ignore */\n\n    \\n+                             /* */\n    \\s+                             /* */\n    {NAME}                          return 'NAME'\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         yytext = yytext.replace(/\\\\\"/g,'\"');return 'STRING_LIT'\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       yytext = yytext.replace(/\\\\'/g,\"'\");return 'STRING_LIT'\n    \"|\"                             return '|'\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"      return 'ANY_GROUP_REGEX'\n    \"(?:\"                           return 'SPECIAL_GROUP'\n    \"(?=\"                           return 'SPECIAL_GROUP'\n    \"(?!\"                           return 'SPECIAL_GROUP'\n    \"(\"                             return '('\n    \")\"                             return ')'\n    \"+\"                             return '+'\n    \"*\"                             return '*'\n    \"?\"                             return '?'\n    \"^\"                             return '^'\n    \",\"                             return ','\n    \"<<EOF>>\"                       return '$'\n    \"<\"                             this.begin('conditions'); return '<'\n    \"/!\"                            return '/!'\n    \"/\"                             return '/'\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4}) return 'ESCAPE_CHAR'\n    \"\\\\\".                           yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR'\n    \"$\"                             return '$'\n    \".\"                             return '.'\n    \"%options\"                      yy.options = {}; this.begin('options')\n    \"%s\"                            this.begin('start_condition');return 'START_INC'\n    \"%x\"                            this.begin('start_condition');return 'START_EXC'\n    \"%%\"                            this.begin('rules'); return '%%'\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"       return 'RANGE_REGEX'\n    \"{\"{NAME}\"}\"                    return 'NAME_BRACE'\n    \"{\"                             return '{'\n    \"}\"                             return '}'\n    .                               /* ignore bad characters */\n    <*><<EOF>>                      return 'EOF'\n\n    <code>(.|\\n)+                   return 'CODE'\n\n    %%\n\n## license\n\nMIT\n","_id":"lex-parser@0.0.1","dist":{"shasum":"0130d101c567bd1af0c163a8c60f07c996d9da5d","tarball":"https://registry.npmjs.org/lex-parser/-/lex-parser-0.0.1.tgz"},"_npmVersion":"1.1.63","_npmUser":{"name":"zaach","email":"zack.carter@gmail.com"},"maintainers":[{"name":"zaach","email":"zack.carter@gmail.com"}],"directories":{}},"0.1.0":{"name":"lex-parser","version":"0.1.0","description":"A parser for lexical grammars used by jison","main":"lex-parser.js","scripts":{"test":"make test"},"repository":"","keywords":["lexical","grammar","parser","jison"],"author":{"name":"Zach Carter"},"license":"MIT","devDependencies":{"jison":"0.4.x","test":"*"},"readme":"# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require('lex-parser');\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME              [a-zA-Z_][a-zA-Z0-9_-]*\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>[^{}]+          return 'ACTION_BODY'\n    <action>\"{\"             yy.depth++; return '{'\n    <action>\"}\"             yy.depth == 0 ? this.begin('trail') : yy.depth--; return '}'\n\n    <conditions>{NAME}      return 'NAME'\n    <conditions>\">\"         this.popState(); return '>'\n    <conditions>\",\"         return ','\n    <conditions>\"*\"         return '*'\n\n    <rules>\\n+              /* */\n    <rules>\\s+              this.begin('indented')\n    <rules>\"%%\"             this.begin('code'); return '%%'\n    <rules>[a-zA-Z0-9_]+    return 'CHARACTER_LIT'\n\n    <options>{NAME}         yy.options[yytext] = true\n    <options>\\n+            this.begin('INITIAL')\n    <options>\\s+\\n+         this.begin('INITIAL')\n    <options>\\s+            /* empty */\n\n    <start_condition>{NAME}         return 'START_COND'\n    <start_condition>\\n+            this.begin('INITIAL')\n    <start_condition>\\s+\\n+         this.begin('INITIAL')\n    <start_condition>\\s+            /* empty */\n\n    <trail>.*\\n+                    this.begin('rules')\n\n    <indented>\"{\"                   yy.depth = 0; this.begin('action'); return '{'\n    <indented>\"%{\"(.|\\n)*?\"%}\"      this.begin('trail'); yytext = yytext.substr(2, yytext.length-4);return 'ACTION'\n    \"%{\"(.|\\n)*?\"%}\"                yytext = yytext.substr(2, yytext.length-4); return 'ACTION'\n    <indented>.+                    this.begin('rules'); return 'ACTION'\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"             /* ignore */\n    \"//\".*                          /* ignore */\n\n    \\n+                             /* */\n    \\s+                             /* */\n    {NAME}                          return 'NAME'\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         yytext = yytext.replace(/\\\\\"/g,'\"');return 'STRING_LIT'\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       yytext = yytext.replace(/\\\\'/g,\"'\");return 'STRING_LIT'\n    \"|\"                             return '|'\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"      return 'ANY_GROUP_REGEX'\n    \"(?:\"                           return 'SPECIAL_GROUP'\n    \"(?=\"                           return 'SPECIAL_GROUP'\n    \"(?!\"                           return 'SPECIAL_GROUP'\n    \"(\"                             return '('\n    \")\"                             return ')'\n    \"+\"                             return '+'\n    \"*\"                             return '*'\n    \"?\"                             return '?'\n    \"^\"                             return '^'\n    \",\"                             return ','\n    \"<<EOF>>\"                       return '$'\n    \"<\"                             this.begin('conditions'); return '<'\n    \"/!\"                            return '/!'\n    \"/\"                             return '/'\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4}) return 'ESCAPE_CHAR'\n    \"\\\\\".                           yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR'\n    \"$\"                             return '$'\n    \".\"                             return '.'\n    \"%options\"                      yy.options = {}; this.begin('options')\n    \"%s\"                            this.begin('start_condition');return 'START_INC'\n    \"%x\"                            this.begin('start_condition');return 'START_EXC'\n    \"%%\"                            this.begin('rules'); return '%%'\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"       return 'RANGE_REGEX'\n    \"{\"{NAME}\"}\"                    return 'NAME_BRACE'\n    \"{\"                             return '{'\n    \"}\"                             return '}'\n    .                               /* ignore bad characters */\n    <*><<EOF>>                      return 'EOF'\n\n    <code>(.|\\n)+                   return 'CODE'\n\n    %%\n\n## license\n\nMIT\n","_id":"lex-parser@0.1.0","dist":{"shasum":"582a8d9a04e91ef6e526ef3217092cb7313fa011","tarball":"https://registry.npmjs.org/lex-parser/-/lex-parser-0.1.0.tgz"},"_npmVersion":"1.1.63","_npmUser":{"name":"zaach","email":"zack.carter@gmail.com"},"maintainers":[{"name":"zaach","email":"zack.carter@gmail.com"}],"directories":{}},"0.1.1":{"name":"lex-parser","version":"0.1.1","description":"A parser for lexical grammars used by jison","main":"lex-parser.js","scripts":{"test":"make test"},"repository":"","keywords":["lexical","grammar","parser","jison"],"author":{"name":"Zach Carter"},"license":"MIT","devDependencies":{"jison":"0.4.x","test":"*"},"readme":"# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require('lex-parser');\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME              [a-zA-Z_][a-zA-Z0-9_-]*\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>[^{}]+          return 'ACTION_BODY'\n    <action>\"{\"             yy.depth++; return '{'\n    <action>\"}\"             yy.depth == 0 ? this.begin('trail') : yy.depth--; return '}'\n\n    <conditions>{NAME}      return 'NAME'\n    <conditions>\">\"         this.popState(); return '>'\n    <conditions>\",\"         return ','\n    <conditions>\"*\"         return '*'\n\n    <rules>\\n+              /* */\n    <rules>\\s+              this.begin('indented')\n    <rules>\"%%\"             this.begin('code'); return '%%'\n    <rules>[a-zA-Z0-9_]+    return 'CHARACTER_LIT'\n\n    <options>{NAME}         yy.options[yytext] = true\n    <options>\\n+            this.begin('INITIAL')\n    <options>\\s+\\n+         this.begin('INITIAL')\n    <options>\\s+            /* empty */\n\n    <start_condition>{NAME}         return 'START_COND'\n    <start_condition>\\n+            this.begin('INITIAL')\n    <start_condition>\\s+\\n+         this.begin('INITIAL')\n    <start_condition>\\s+            /* empty */\n\n    <trail>.*\\n+                    this.begin('rules')\n\n    <indented>\"{\"                   yy.depth = 0; this.begin('action'); return '{'\n    <indented>\"%{\"(.|\\n)*?\"%}\"      this.begin('trail'); yytext = yytext.substr(2, yytext.length-4);return 'ACTION'\n    \"%{\"(.|\\n)*?\"%}\"                yytext = yytext.substr(2, yytext.length-4); return 'ACTION'\n    <indented>.+                    this.begin('rules'); return 'ACTION'\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"             /* ignore */\n    \"//\".*                          /* ignore */\n\n    \\n+                             /* */\n    \\s+                             /* */\n    {NAME}                          return 'NAME'\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         yytext = yytext.replace(/\\\\\"/g,'\"');return 'STRING_LIT'\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       yytext = yytext.replace(/\\\\'/g,\"'\");return 'STRING_LIT'\n    \"|\"                             return '|'\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"      return 'ANY_GROUP_REGEX'\n    \"(?:\"                           return 'SPECIAL_GROUP'\n    \"(?=\"                           return 'SPECIAL_GROUP'\n    \"(?!\"                           return 'SPECIAL_GROUP'\n    \"(\"                             return '('\n    \")\"                             return ')'\n    \"+\"                             return '+'\n    \"*\"                             return '*'\n    \"?\"                             return '?'\n    \"^\"                             return '^'\n    \",\"                             return ','\n    \"<<EOF>>\"                       return '$'\n    \"<\"                             this.begin('conditions'); return '<'\n    \"/!\"                            return '/!'\n    \"/\"                             return '/'\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4}) return 'ESCAPE_CHAR'\n    \"\\\\\".                           yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR'\n    \"$\"                             return '$'\n    \".\"                             return '.'\n    \"%options\"                      yy.options = {}; this.begin('options')\n    \"%s\"                            this.begin('start_condition');return 'START_INC'\n    \"%x\"                            this.begin('start_condition');return 'START_EXC'\n    \"%%\"                            this.begin('rules'); return '%%'\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"       return 'RANGE_REGEX'\n    \"{\"{NAME}\"}\"                    return 'NAME_BRACE'\n    \"{\"                             return '{'\n    \"}\"                             return '}'\n    .                               /* ignore bad characters */\n    <*><<EOF>>                      return 'EOF'\n\n    <code>(.|\\n)+                   return 'CODE'\n\n    %%\n\n## license\n\nMIT\n","readmeFilename":"README.md","_id":"lex-parser@0.1.1","dist":{"shasum":"1ebbea4ae56ffa39113ab6458a9149712685810d","tarball":"https://registry.npmjs.org/lex-parser/-/lex-parser-0.1.1.tgz"},"_from":".","_npmVersion":"1.2.10","_npmUser":{"name":"zaach","email":"zack.carter@gmail.com"},"maintainers":[{"name":"zaach","email":"zack.carter@gmail.com"}],"directories":{}},"0.1.2":{"name":"lex-parser","version":"0.1.2","description":"A parser for lexical grammars used by jison","main":"lex-parser.js","scripts":{"test":"make test"},"repository":"","keywords":["lexical","grammar","parser","jison"],"author":{"name":"Zach Carter"},"license":"MIT","devDependencies":{"jison":"0.4.x","test":"*"},"readme":"# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require('lex-parser');\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME              [a-zA-Z_][a-zA-Z0-9_-]*\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>[^{}]+          return 'ACTION_BODY'\n    <action>\"{\"             yy.depth++; return '{'\n    <action>\"}\"             yy.depth == 0 ? this.begin('trail') : yy.depth--; return '}'\n\n    <conditions>{NAME}      return 'NAME'\n    <conditions>\">\"         this.popState(); return '>'\n    <conditions>\",\"         return ','\n    <conditions>\"*\"         return '*'\n\n    <rules>\\n+              /* */\n    <rules>\\s+              this.begin('indented')\n    <rules>\"%%\"             this.begin('code'); return '%%'\n    <rules>[a-zA-Z0-9_]+    return 'CHARACTER_LIT'\n\n    <options>{NAME}         yy.options[yytext] = true\n    <options>\\n+            this.begin('INITIAL')\n    <options>\\s+\\n+         this.begin('INITIAL')\n    <options>\\s+            /* empty */\n\n    <start_condition>{NAME}         return 'START_COND'\n    <start_condition>\\n+            this.begin('INITIAL')\n    <start_condition>\\s+\\n+         this.begin('INITIAL')\n    <start_condition>\\s+            /* empty */\n\n    <trail>.*\\n+                    this.begin('rules')\n\n    <indented>\"{\"                   yy.depth = 0; this.begin('action'); return '{'\n    <indented>\"%{\"(.|\\n)*?\"%}\"      this.begin('trail'); yytext = yytext.substr(2, yytext.length-4);return 'ACTION'\n    \"%{\"(.|\\n)*?\"%}\"                yytext = yytext.substr(2, yytext.length-4); return 'ACTION'\n    <indented>.+                    this.begin('rules'); return 'ACTION'\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"             /* ignore */\n    \"//\".*                          /* ignore */\n\n    \\n+                             /* */\n    \\s+                             /* */\n    {NAME}                          return 'NAME'\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         yytext = yytext.replace(/\\\\\"/g,'\"');return 'STRING_LIT'\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       yytext = yytext.replace(/\\\\'/g,\"'\");return 'STRING_LIT'\n    \"|\"                             return '|'\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"      return 'ANY_GROUP_REGEX'\n    \"(?:\"                           return 'SPECIAL_GROUP'\n    \"(?=\"                           return 'SPECIAL_GROUP'\n    \"(?!\"                           return 'SPECIAL_GROUP'\n    \"(\"                             return '('\n    \")\"                             return ')'\n    \"+\"                             return '+'\n    \"*\"                             return '*'\n    \"?\"                             return '?'\n    \"^\"                             return '^'\n    \",\"                             return ','\n    \"<<EOF>>\"                       return '$'\n    \"<\"                             this.begin('conditions'); return '<'\n    \"/!\"                            return '/!'\n    \"/\"                             return '/'\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4}) return 'ESCAPE_CHAR'\n    \"\\\\\".                           yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR'\n    \"$\"                             return '$'\n    \".\"                             return '.'\n    \"%options\"                      yy.options = {}; this.begin('options')\n    \"%s\"                            this.begin('start_condition');return 'START_INC'\n    \"%x\"                            this.begin('start_condition');return 'START_EXC'\n    \"%%\"                            this.begin('rules'); return '%%'\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"       return 'RANGE_REGEX'\n    \"{\"{NAME}\"}\"                    return 'NAME_BRACE'\n    \"{\"                             return '{'\n    \"}\"                             return '}'\n    .                               /* ignore bad characters */\n    <*><<EOF>>                      return 'EOF'\n\n    <code>(.|\\n)+                   return 'CODE'\n\n    %%\n\n## license\n\nMIT\n","readmeFilename":"README.md","_id":"lex-parser@0.1.2","dist":{"shasum":"cc5712e361aaabd4a1bb75c469b8acaec15e0ec6","tarball":"https://registry.npmjs.org/lex-parser/-/lex-parser-0.1.2.tgz"},"_from":".","_npmVersion":"1.2.10","_npmUser":{"name":"zaach","email":"zack.carter@gmail.com"},"maintainers":[{"name":"zaach","email":"zack.carter@gmail.com"}],"directories":{}},"0.1.3":{"name":"lex-parser","version":"0.1.3","description":"A parser for lexical grammars used by jison","main":"lex-parser.js","scripts":{"test":"make test"},"repository":{"type":"git","repository":"https://github.com/zaach/lex-parser.git"},"keywords":["lexical","grammar","parser","jison"],"author":{"name":"Zach Carter"},"license":"MIT","devDependencies":{"jison":"0.4.x","test":"*"},"readme":"# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require('lex-parser');\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME              [a-zA-Z_][a-zA-Z0-9_-]*\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>[^{}]+          return 'ACTION_BODY'\n    <action>\"{\"             yy.depth++; return '{'\n    <action>\"}\"             yy.depth == 0 ? this.begin('trail') : yy.depth--; return '}'\n\n    <conditions>{NAME}      return 'NAME'\n    <conditions>\">\"         this.popState(); return '>'\n    <conditions>\",\"         return ','\n    <conditions>\"*\"         return '*'\n\n    <rules>\\n+              /* */\n    <rules>\\s+              this.begin('indented')\n    <rules>\"%%\"             this.begin('code'); return '%%'\n    <rules>[a-zA-Z0-9_]+    return 'CHARACTER_LIT'\n\n    <options>{NAME}         yy.options[yytext] = true\n    <options>\\n+            this.begin('INITIAL')\n    <options>\\s+\\n+         this.begin('INITIAL')\n    <options>\\s+            /* empty */\n\n    <start_condition>{NAME}         return 'START_COND'\n    <start_condition>\\n+            this.begin('INITIAL')\n    <start_condition>\\s+\\n+         this.begin('INITIAL')\n    <start_condition>\\s+            /* empty */\n\n    <trail>.*\\n+                    this.begin('rules')\n\n    <indented>\"{\"                   yy.depth = 0; this.begin('action'); return '{'\n    <indented>\"%{\"(.|\\n)*?\"%}\"      this.begin('trail'); yytext = yytext.substr(2, yytext.length-4);return 'ACTION'\n    \"%{\"(.|\\n)*?\"%}\"                yytext = yytext.substr(2, yytext.length-4); return 'ACTION'\n    <indented>.+                    this.begin('rules'); return 'ACTION'\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"             /* ignore */\n    \"//\".*                          /* ignore */\n\n    \\n+                             /* */\n    \\s+                             /* */\n    {NAME}                          return 'NAME'\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         yytext = yytext.replace(/\\\\\"/g,'\"');return 'STRING_LIT'\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       yytext = yytext.replace(/\\\\'/g,\"'\");return 'STRING_LIT'\n    \"|\"                             return '|'\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"      return 'ANY_GROUP_REGEX'\n    \"(?:\"                           return 'SPECIAL_GROUP'\n    \"(?=\"                           return 'SPECIAL_GROUP'\n    \"(?!\"                           return 'SPECIAL_GROUP'\n    \"(\"                             return '('\n    \")\"                             return ')'\n    \"+\"                             return '+'\n    \"*\"                             return '*'\n    \"?\"                             return '?'\n    \"^\"                             return '^'\n    \",\"                             return ','\n    \"<<EOF>>\"                       return '$'\n    \"<\"                             this.begin('conditions'); return '<'\n    \"/!\"                            return '/!'\n    \"/\"                             return '/'\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4}) return 'ESCAPE_CHAR'\n    \"\\\\\".                           yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR'\n    \"$\"                             return '$'\n    \".\"                             return '.'\n    \"%options\"                      yy.options = {}; this.begin('options')\n    \"%s\"                            this.begin('start_condition');return 'START_INC'\n    \"%x\"                            this.begin('start_condition');return 'START_EXC'\n    \"%%\"                            this.begin('rules'); return '%%'\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"       return 'RANGE_REGEX'\n    \"{\"{NAME}\"}\"                    return 'NAME_BRACE'\n    \"{\"                             return '{'\n    \"}\"                             return '}'\n    .                               /* ignore bad characters */\n    <*><<EOF>>                      return 'EOF'\n\n    <code>(.|\\n)+                   return 'CODE'\n\n    %%\n\n## license\n\nMIT\n","readmeFilename":"README.md","_id":"lex-parser@0.1.3","dist":{"shasum":"479be9bded0ba61217c2cc0fa6e76be00e988bd6","tarball":"https://registry.npmjs.org/lex-parser/-/lex-parser-0.1.3.tgz"},"_from":".","_npmVersion":"1.3.5","_npmUser":{"name":"zaach","email":"zack.carter@gmail.com"},"maintainers":[{"name":"zaach","email":"zack.carter@gmail.com"}],"directories":{}},"0.1.4":{"name":"lex-parser","version":"0.1.4","description":"A parser for lexical grammars used by jison","main":"lex-parser.js","scripts":{"test":"make test"},"repository":{"type":"git","repository":"https://github.com/zaach/lex-parser.git"},"keywords":["lexical","grammar","parser","jison"],"author":{"name":"Zach Carter"},"license":"MIT","devDependencies":{"jison":"0.4.x","test":"*"},"readme":"# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require(\"lex-parser\");\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME              [a-zA-Z_][a-zA-Z0-9_-]*\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>[^{}]+          return 'ACTION_BODY'\n    <action>\"{\"             yy.depth++; return '{'\n    <action>\"}\"             yy.depth == 0 ? this.begin('trail') : yy.depth--; return '}'\n\n    <conditions>{NAME}      return 'NAME'\n    <conditions>\">\"         this.popState(); return '>'\n    <conditions>\",\"         return ','\n    <conditions>\"*\"         return '*'\n\n    <rules>\\n+              /* */\n    <rules>\\s+              this.begin('indented')\n    <rules>\"%%\"             this.begin('code'); return '%%'\n    <rules>[a-zA-Z0-9_]+    return 'CHARACTER_LIT'\n\n    <options>{NAME}         yy.options[yytext] = true\n    <options>\\n+            this.begin('INITIAL')\n    <options>\\s+\\n+         this.begin('INITIAL')\n    <options>\\s+            /* empty */\n\n    <start_condition>{NAME}         return 'START_COND'\n    <start_condition>\\n+            this.begin('INITIAL')\n    <start_condition>\\s+\\n+         this.begin('INITIAL')\n    <start_condition>\\s+            /* empty */\n\n    <trail>.*\\n+                    this.begin('rules')\n\n    <indented>\"{\"                   yy.depth = 0; this.begin('action'); return '{'\n    <indented>\"%{\"(.|\\n)*?\"%}\"      this.begin('trail'); yytext = yytext.substr(2, yytext.length-4);return 'ACTION'\n    \"%{\"(.|\\n)*?\"%}\"                yytext = yytext.substr(2, yytext.length-4); return 'ACTION'\n    <indented>.+                    this.begin('rules'); return 'ACTION'\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"             /* ignore */\n    \"//\".*                          /* ignore */\n\n    \\n+                             /* */\n    \\s+                             /* */\n    {NAME}                          return 'NAME'\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         yytext = yytext.replace(/\\\\\"/g,'\"');return 'STRING_LIT'\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       yytext = yytext.replace(/\\\\'/g,\"'\");return 'STRING_LIT'\n    \"|\"                             return '|'\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"      return 'ANY_GROUP_REGEX'\n    \"(?:\"                           return 'SPECIAL_GROUP'\n    \"(?=\"                           return 'SPECIAL_GROUP'\n    \"(?!\"                           return 'SPECIAL_GROUP'\n    \"(\"                             return '('\n    \")\"                             return ')'\n    \"+\"                             return '+'\n    \"*\"                             return '*'\n    \"?\"                             return '?'\n    \"^\"                             return '^'\n    \",\"                             return ','\n    \"<<EOF>>\"                       return '$'\n    \"<\"                             this.begin('conditions'); return '<'\n    \"/!\"                            return '/!'\n    \"/\"                             return '/'\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4}) return 'ESCAPE_CHAR'\n    \"\\\\\".                           yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR'\n    \"$\"                             return '$'\n    \".\"                             return '.'\n    \"%options\"                      yy.options = {}; this.begin('options')\n    \"%s\"                            this.begin('start_condition');return 'START_INC'\n    \"%x\"                            this.begin('start_condition');return 'START_EXC'\n    \"%%\"                            this.begin('rules'); return '%%'\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"       return 'RANGE_REGEX'\n    \"{\"{NAME}\"}\"                    return 'NAME_BRACE'\n    \"{\"                             return '{'\n    \"}\"                             return '}'\n    .                               /* ignore bad characters */\n    <*><<EOF>>                      return 'EOF'\n\n    <code>(.|\\n)+                   return 'CODE'\n\n    %%\n\n## license\n\nMIT\n","readmeFilename":"README.md","_id":"lex-parser@0.1.4","dist":{"shasum":"64c4f025f17fd53bfb45763faeb16f015a747550","tarball":"https://registry.npmjs.org/lex-parser/-/lex-parser-0.1.4.tgz"},"_from":".","_npmVersion":"1.3.5","_npmUser":{"name":"zaach","email":"zack.carter@gmail.com"},"maintainers":[{"name":"zaach","email":"zack.carter@gmail.com"}],"directories":{}}},"readme":"# lex-parser\n\nA parser for lexical grammars used by [jison](http://jison.org) and jison-lex.\n\n## install\n\n    npm install lex-parser\n\n## build\n\nTo build the parser yourself, clone the git repo then run:\n\n    make\n\nThis will generate `lex-parser.js`.\n\n## usage\n\n    var lexParser = require('lex-parser');\n\n    // parse a lexical grammar and return JSON\n    lexParser.parse(\"%% ... \");\n\n## example\n\nThe parser can parse its own lexical grammar, shown below:\n\n    NAME              [a-zA-Z_][a-zA-Z0-9_-]*\n\n    %s indented trail rules\n    %x code start_condition options conditions action\n\n    %%\n\n    <action>[^{}]+          return 'ACTION_BODY'\n    <action>\"{\"             yy.depth++; return '{'\n    <action>\"}\"             yy.depth == 0 ? this.begin('trail') : yy.depth--; return '}'\n\n    <conditions>{NAME}      return 'NAME'\n    <conditions>\">\"         this.popState(); return '>'\n    <conditions>\",\"         return ','\n    <conditions>\"*\"         return '*'\n\n    <rules>\\n+              /* */\n    <rules>\\s+              this.begin('indented')\n    <rules>\"%%\"             this.begin('code'); return '%%'\n    <rules>[a-zA-Z0-9_]+    return 'CHARACTER_LIT'\n\n    <options>{NAME}         yy.options[yytext] = true\n    <options>\\n+            this.begin('INITIAL')\n    <options>\\s+\\n+         this.begin('INITIAL')\n    <options>\\s+            /* empty */\n\n    <start_condition>{NAME}         return 'START_COND'\n    <start_condition>\\n+            this.begin('INITIAL')\n    <start_condition>\\s+\\n+         this.begin('INITIAL')\n    <start_condition>\\s+            /* empty */\n\n    <trail>.*\\n+                    this.begin('rules')\n\n    <indented>\"{\"                   yy.depth = 0; this.begin('action'); return '{'\n    <indented>\"%{\"(.|\\n)*?\"%}\"      this.begin('trail'); yytext = yytext.substr(2, yytext.length-4);return 'ACTION'\n    \"%{\"(.|\\n)*?\"%}\"                yytext = yytext.substr(2, yytext.length-4); return 'ACTION'\n    <indented>.+                    this.begin('rules'); return 'ACTION'\n\n    \"/*\"(.|\\n|\\r)*?\"*/\"             /* ignore */\n    \"//\".*                          /* ignore */\n\n    \\n+                             /* */\n    \\s+                             /* */\n    {NAME}                          return 'NAME'\n    \\\"(\"\\\\\\\\\"|'\\\"'|[^\"])*\\\"         yytext = yytext.replace(/\\\\\"/g,'\"');return 'STRING_LIT'\n    \"'\"(\"\\\\\\\\\"|\"\\'\"|[^'])*\"'\"       yytext = yytext.replace(/\\\\'/g,\"'\");return 'STRING_LIT'\n    \"|\"                             return '|'\n    \"[\"(\"\\\\\\\\\"|\"\\]\"|[^\\]])*\"]\"      return 'ANY_GROUP_REGEX'\n    \"(?:\"                           return 'SPECIAL_GROUP'\n    \"(?=\"                           return 'SPECIAL_GROUP'\n    \"(?!\"                           return 'SPECIAL_GROUP'\n    \"(\"                             return '('\n    \")\"                             return ')'\n    \"+\"                             return '+'\n    \"*\"                             return '*'\n    \"?\"                             return '?'\n    \"^\"                             return '^'\n    \",\"                             return ','\n    \"<<EOF>>\"                       return '$'\n    \"<\"                             this.begin('conditions'); return '<'\n    \"/!\"                            return '/!'\n    \"/\"                             return '/'\n    \"\\\\\"([0-7]{1,3}|[rfntvsSbBwWdD\\\\*+()${}|[\\]\\/.^?]|\"c\"[A-Z]|\"x\"[0-9A-F]{2}|\"u\"[a-fA-F0-9]{4}) return 'ESCAPE_CHAR'\n    \"\\\\\".                           yytext = yytext.replace(/^\\\\/g,''); return 'ESCAPE_CHAR'\n    \"$\"                             return '$'\n    \".\"                             return '.'\n    \"%options\"                      yy.options = {}; this.begin('options')\n    \"%s\"                            this.begin('start_condition');return 'START_INC'\n    \"%x\"                            this.begin('start_condition');return 'START_EXC'\n    \"%%\"                            this.begin('rules'); return '%%'\n    \"{\"\\d+(\",\"\\s?\\d+|\",\")?\"}\"       return 'RANGE_REGEX'\n    \"{\"{NAME}\"}\"                    return 'NAME_BRACE'\n    \"{\"                             return '{'\n    \"}\"                             return '}'\n    .                               /* ignore bad characters */\n    <*><<EOF>>                      return 'EOF'\n\n    <code>(.|\\n)+                   return 'CODE'\n\n    %%\n\n## license\n\nMIT\n","maintainers":[{"name":"zaach","email":"zack.carter@gmail.com"}],"time":{"modified":"2013-08-04T02:13:26.721Z","created":"2013-01-27T03:18:10.806Z","0.0.1":"2013-01-27T03:18:11.544Z","0.1.0":"2013-01-28T03:37:45.642Z","0.1.1":"2013-06-22T18:46:13.738Z","0.1.2":"2013-06-22T19:46:58.186Z","0.1.3":"2013-07-27T22:26:13.868Z","0.1.4":"2013-08-04T02:13:26.721Z"},"author":{"name":"Zach Carter"},"repository":{"type":"git","repository":"https://github.com/zaach/lex-parser.git"},"users":{"wenbing":true,"yvesm":true},"_attachments":{},"_etag":"\"BLV6X0YPXYPRI0CON5TOKG770\""}